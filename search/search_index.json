{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Articles 2020-02-11 : How to quickly and properly delete a Team (without waiting) Tips & Tricks 2020-02-13 : [CSOM] Test in your C# code if a SharePoint File or Folder exists 2020-05-05 : [SPFx] Transform the Fluent UI ProgressIndicator component into a countdown timer","title":"Home"},{"location":"#articles","text":"2020-02-11 : How to quickly and properly delete a Team (without waiting)","title":"Articles"},{"location":"#tips-tricks","text":"2020-02-13 : [CSOM] Test in your C# code if a SharePoint File or Folder exists 2020-05-05 : [SPFx] Transform the Fluent UI ProgressIndicator component into a countdown timer","title":"Tips &amp; Tricks"},{"location":"about/","text":"About this blog Who Am I Hi ! I'm Micha\u00ebl, Software Engineer for onepoint based in Nantes, France. I'm +10yr experienced in SharePoint solutions (started from the 2007 version) and since 2017, I'm focused on developing SPFx solutions, working with Office 365 Managed Services and Azure Services, exploring Microsoft Graph and Identity. I also (try to) contribute to the PnP Initiative with amazing people ! In this blog, I'll talk about things I learned day by day since I started to work with SharePoint Products (articles, memos,...). Why Now It's hard to convince yourself \"Ok, let's open to the world\". I think I was waiting for the right time. When I see how the Microsoft Community has grown up, especially in the Office 365 bubble, I think that it could be helpful to anyone who, like me, wants to find some answers to technical issues met (missing puzzle piece \ud83d\ude09). Why In English Because it's easier to reach out a maximum of people \ud83e\udd17 Hope you'll find what you're looking for, see you online or IRL !","title":"About"},{"location":"about/#about-this-blog","text":"","title":"About this blog"},{"location":"about/#who-am-i","text":"Hi ! I'm Micha\u00ebl, Software Engineer for onepoint based in Nantes, France. I'm +10yr experienced in SharePoint solutions (started from the 2007 version) and since 2017, I'm focused on developing SPFx solutions, working with Office 365 Managed Services and Azure Services, exploring Microsoft Graph and Identity. I also (try to) contribute to the PnP Initiative with amazing people ! In this blog, I'll talk about things I learned day by day since I started to work with SharePoint Products (articles, memos,...).","title":"Who Am I"},{"location":"about/#why-now","text":"It's hard to convince yourself \"Ok, let's open to the world\". I think I was waiting for the right time. When I see how the Microsoft Community has grown up, especially in the Office 365 bubble, I think that it could be helpful to anyone who, like me, wants to find some answers to technical issues met (missing puzzle piece \ud83d\ude09).","title":"Why Now"},{"location":"about/#why-in-english","text":"Because it's easier to reach out a maximum of people \ud83e\udd17 Hope you'll find what you're looking for, see you online or IRL !","title":"Why In English"},{"location":"articles/20200211-properly-remove-team/","text":"How to quickly and properly delete a Team (without waiting) Use Case You work for a company that wants to automatically create a Team with Tabs, Channels and other stuff that will make a new project team ready to rock the stage. You are preparing the process and for mastering it, you have create / test / destroy / retry. But when you want to clean up your mess, you have to know that, during 30 days: Your Team still exists as a Group (you can find it in the \"Deleted Groups\" menu on AAD), same for the associated e-mail address The Teams Site also still exists So let's says that you made a mistake during the creation of a Team and want to \"start over\" (with same name of course), if you don't want to wait for the Office 365 Job to update your environment and re-create the Team with same name: The SharePoint Site URL takes a number at the end of its address (of course, because the older one's still here) You can't permanently delete the Teams Site, as the SharePoint Admin Center detects that the related Group still exists Here's a step by step process to delete quickly a Team ! I recommand to follow them in this order to make everything's work. Prerequisites An Office 365 (Dev) Tenant An Account with the following Office 365 roles SharePoint Admin Teams Admin An Account with the following Azure AD role Groups administrator PowerShell or Office 365 CLI Delete Group in Azure With Interface Throught the UI, you have to delete the Group then permanently delete it With code PowerShell 1 2 3 4 # With the AAD PowerShell **2.0-preview** module Connect-AzureAD -TenantId \"TenantId\" Remove-AzureADGroup -ObjectId \"GroupId\" Remove-AzureADMSDeletedDirectoryObject -Id \"GroupId\" Office 365 CLI 1 2 3 # (As there's no CLI command to permanently delete a Group, # you'll have to do it through the UI) aad o365group remove --id \"groupId\" --confirm Delete Team (if necessary) Sometimes, once a Group is permanently deleted, the Team still exists. If it's the case and once again, you don't want for the Job to delete it, you can do it yourself. But don't be surprise if the following commands throw an error : maybe the Job has already worked. With Interface Throught the UI (if you have an owner account) or Admin Interface, you can delete the Team OR With the Teams PowerShell module 1 2 Connect-MicrosoftTeams -TenantId \"TenantId\" Remove-Team -GroupId \"GroupId\" Delete Site Collection As I told you before (even if you did the previous steps), if you try to delete the Teams Site from the SharePoint Admin Center, you won't be able to remove it from the Site Collection Recycle Bin (because of the O365 Job Tenant update process). With code So the solution here is to delete the Site with PowerShell (SharePoint PnP PoweShell module), like this: PowerShell 1 2 3 4 5 6 7 # If you are familiar with the Get-PnPStoredCredential cmdlet, # you can use it here with the \"-Credential\" Argument Connect-PnPOnline -TenantId \"TenantId\" Remove-PnPTenantSite -Url \"TeamsSiteUrl\" -Force -SkipRecycleBin # If it's already in Recycle Bin Clear-PnPTenantRecycleBinItem -Url \"TeamsSiteUrl\" -Force -Wait Office 365 CLI 1 2 3 4 # (If it's already in Site Collection Recycle Bin, you'll have to delete it # from the UI or through another API like SharePoint or Graph) spo site classic remove -u \"url\" --skipRecycleBin --confirm --wait That's it Et voil\u00e0 ! You can start over your process until it's ready to use. Of course, you could also make those tasks with the SharePoint Online Management Shell or with the Graph API, but here I've covered the most common ways of working with Teams / Group / SharePoint administration. Useful Links AAD PowerShell module SharePointPnPPowerShellOnline module MicrosoftTeams PowerShell module Office 365 CLI Microsoft Teams Architecture Microsoft Teams Architecture Posters","title":"How to quickly and properly delete a Team (without waiting)"},{"location":"articles/20200211-properly-remove-team/#how-to-quickly-and-properly-delete-a-team-without-waiting","text":"","title":"How to quickly and properly delete a Team (without waiting)"},{"location":"articles/20200211-properly-remove-team/#use-case","text":"You work for a company that wants to automatically create a Team with Tabs, Channels and other stuff that will make a new project team ready to rock the stage. You are preparing the process and for mastering it, you have create / test / destroy / retry. But when you want to clean up your mess, you have to know that, during 30 days: Your Team still exists as a Group (you can find it in the \"Deleted Groups\" menu on AAD), same for the associated e-mail address The Teams Site also still exists So let's says that you made a mistake during the creation of a Team and want to \"start over\" (with same name of course), if you don't want to wait for the Office 365 Job to update your environment and re-create the Team with same name: The SharePoint Site URL takes a number at the end of its address (of course, because the older one's still here) You can't permanently delete the Teams Site, as the SharePoint Admin Center detects that the related Group still exists Here's a step by step process to delete quickly a Team ! I recommand to follow them in this order to make everything's work.","title":"Use Case"},{"location":"articles/20200211-properly-remove-team/#prerequisites","text":"An Office 365 (Dev) Tenant An Account with the following Office 365 roles SharePoint Admin Teams Admin An Account with the following Azure AD role Groups administrator PowerShell or Office 365 CLI","title":"Prerequisites"},{"location":"articles/20200211-properly-remove-team/#delete-group-in-azure","text":"","title":"Delete Group in Azure"},{"location":"articles/20200211-properly-remove-team/#with-interface","text":"Throught the UI, you have to delete the Group then permanently delete it","title":"With Interface"},{"location":"articles/20200211-properly-remove-team/#with-code","text":"PowerShell 1 2 3 4 # With the AAD PowerShell **2.0-preview** module Connect-AzureAD -TenantId \"TenantId\" Remove-AzureADGroup -ObjectId \"GroupId\" Remove-AzureADMSDeletedDirectoryObject -Id \"GroupId\" Office 365 CLI 1 2 3 # (As there's no CLI command to permanently delete a Group, # you'll have to do it through the UI) aad o365group remove --id \"groupId\" --confirm","title":"With code"},{"location":"articles/20200211-properly-remove-team/#delete-team-if-necessary","text":"Sometimes, once a Group is permanently deleted, the Team still exists. If it's the case and once again, you don't want for the Job to delete it, you can do it yourself. But don't be surprise if the following commands throw an error : maybe the Job has already worked.","title":"Delete Team (if necessary)"},{"location":"articles/20200211-properly-remove-team/#with-interface_1","text":"Throught the UI (if you have an owner account) or Admin Interface, you can delete the Team OR","title":"With Interface"},{"location":"articles/20200211-properly-remove-team/#with-the-teams-powershell-module","text":"1 2 Connect-MicrosoftTeams -TenantId \"TenantId\" Remove-Team -GroupId \"GroupId\"","title":"With the Teams PowerShell module"},{"location":"articles/20200211-properly-remove-team/#delete-site-collection","text":"As I told you before (even if you did the previous steps), if you try to delete the Teams Site from the SharePoint Admin Center, you won't be able to remove it from the Site Collection Recycle Bin (because of the O365 Job Tenant update process).","title":"Delete Site Collection"},{"location":"articles/20200211-properly-remove-team/#with-code_1","text":"So the solution here is to delete the Site with PowerShell (SharePoint PnP PoweShell module), like this: PowerShell 1 2 3 4 5 6 7 # If you are familiar with the Get-PnPStoredCredential cmdlet, # you can use it here with the \"-Credential\" Argument Connect-PnPOnline -TenantId \"TenantId\" Remove-PnPTenantSite -Url \"TeamsSiteUrl\" -Force -SkipRecycleBin # If it's already in Recycle Bin Clear-PnPTenantRecycleBinItem -Url \"TeamsSiteUrl\" -Force -Wait Office 365 CLI 1 2 3 4 # (If it's already in Site Collection Recycle Bin, you'll have to delete it # from the UI or through another API like SharePoint or Graph) spo site classic remove -u \"url\" --skipRecycleBin --confirm --wait","title":"With code"},{"location":"articles/20200211-properly-remove-team/#thats-it","text":"Et voil\u00e0 ! You can start over your process until it's ready to use. Of course, you could also make those tasks with the SharePoint Online Management Shell or with the Graph API, but here I've covered the most common ways of working with Teams / Group / SharePoint administration.","title":"That's it"},{"location":"articles/20200211-properly-remove-team/#useful-links","text":"AAD PowerShell module SharePointPnPPowerShellOnline module MicrosoftTeams PowerShell module Office 365 CLI Microsoft Teams Architecture Microsoft Teams Architecture Posters","title":"Useful Links"},{"location":"tips/20200213-csom-test-file-folder-existence/","text":"[CSOM] Test in your C# code if a SharePoint File or Folder exists A Simple Use Case When you want to know if a file or folder already exists on a SharePoint Site (in a migration use case for example, before perform a copy / move), you can have some bad surprises. Let's try with a simple folder case example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 string userName = \"user@tenant.onmicrosoft.com\" ; SecureString securePassword = new SecureString (); foreach ( var cc in \"yourPlainTextPassword\" ) { securePassword . AppendChar ( cc ); } using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { spContext . Credentials = new SharePointOnlineCredentials ( userName , securePassword ); spContext . ExecuteQuery (); Web currentWeb = spContext . Web ; List docLibrary = currentWeb . Lists . GetByTitle ( \"Documents\" ); spContext . Load ( docLibrary ); spContext . Load ( docLibrary . RootFolder ); spContext . ExecuteQuery (); string folderPath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFolderThatDoesNotExists\" ; Folder folderToGet = currentWeb . GetFolderByServerRelativeUrl ( folderPath ); spContext . Load ( folderToGet , f => f . Exists ); try { spContext . ExecuteQuery (); if ( folderToGet . Exists ) { // Do something } else { // Do something else } } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } } The twisted thing here's that the if (folderToGet.Exists) line won't be reached. Because if you use the \"GetFolderByServerRelativeUrl\" and the folder actually doesn't exists (or any parent folder in the hierarchy), it'll throw an exception. But if it exists, then you'll be able to test the value of folderToGet.Exists property (which obviously will return true ). Clever. So you want to test if a folder exists but without to constantly catch the error... Good news : the SharePointPnPCoreOnline Package implements this ! Let's try it : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string folderPath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFileThatDoesNotExists\" ; bool exists = currentWeb . DoesFolderExists ( folderPath ); if ( exists ) { // Do something } else { // Do something else } } And that's it ! The DoesFolderExists Method provides this test. And it also works with folder hierarchy containing special characters \ud83d\ude09. For testing the existance of a file, there's not any equivalent. So if you try to get a file that doesn't exists : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string filePath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFileThatDoesNotExists\" ; File fileToGet = currentWeb . GetFileByServerRelativeUrl ( filePath ); spContext . Load ( fileToGet , f => f . Exists ); try { spContext . ExecuteQuery (); } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } } It'll also throw an exception. So the thing here is to use the GetFileByServerRelativePath method which returns a File object, whether it exists or not. And there : the \"Exists\" property can be used. The great thing about this method is that it also works if you file (or your folder hierarchy) contains special characters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string filePath = docLibrary . RootFolder . ServerRelativeUrl + \"/# My Tricky File \u00fch\u00fch\u00fc.docx\" ; File fileToGet = currentWeb . GetFileByServerRelativePath ( ResourcePath . FromDecodedUrl ( filePath )); spContext . Load ( fileToGet , f => f . Exists ); try { spContext . ExecuteQuery (); if ( fileToGet . Exists ) { // Do something } else { // Do something else } } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } } Bonus : Using the Windows Credential Manager For Windows users, if you don't want to always write your credentials and if you already know the Add / Get -PnPStoredCredential cmdlets, you might be interested to use the CredentialManager class provided by the Adys Tech company. You can fin the Nugget package here . Then, when referencing it, you just have to use it like this: 1 2 3 var cred = CredentialManager . GetCredentials ( \"PnPPS:CredentialsName\" ); string user = cred . UserName ; SecureString pwd = cred . SecurePassword ; Useful Links FileFolderExtensions.DoesFolderExists from SharePoint Online PnP Core Supporting % and # in files and folders with the ResourcePath API","title":"[CSOM] Test in your C# code if a SharePoint File or Folder exists"},{"location":"tips/20200213-csom-test-file-folder-existence/#csom-test-in-your-c-code-if-a-sharepoint-file-or-folder-exists","text":"","title":"[CSOM] Test in your C# code if a SharePoint File or Folder exists"},{"location":"tips/20200213-csom-test-file-folder-existence/#a-simple-use-case","text":"When you want to know if a file or folder already exists on a SharePoint Site (in a migration use case for example, before perform a copy / move), you can have some bad surprises. Let's try with a simple folder case example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 string userName = \"user@tenant.onmicrosoft.com\" ; SecureString securePassword = new SecureString (); foreach ( var cc in \"yourPlainTextPassword\" ) { securePassword . AppendChar ( cc ); } using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { spContext . Credentials = new SharePointOnlineCredentials ( userName , securePassword ); spContext . ExecuteQuery (); Web currentWeb = spContext . Web ; List docLibrary = currentWeb . Lists . GetByTitle ( \"Documents\" ); spContext . Load ( docLibrary ); spContext . Load ( docLibrary . RootFolder ); spContext . ExecuteQuery (); string folderPath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFolderThatDoesNotExists\" ; Folder folderToGet = currentWeb . GetFolderByServerRelativeUrl ( folderPath ); spContext . Load ( folderToGet , f => f . Exists ); try { spContext . ExecuteQuery (); if ( folderToGet . Exists ) { // Do something } else { // Do something else } } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } } The twisted thing here's that the if (folderToGet.Exists) line won't be reached. Because if you use the \"GetFolderByServerRelativeUrl\" and the folder actually doesn't exists (or any parent folder in the hierarchy), it'll throw an exception. But if it exists, then you'll be able to test the value of folderToGet.Exists property (which obviously will return true ). Clever. So you want to test if a folder exists but without to constantly catch the error... Good news : the SharePointPnPCoreOnline Package implements this ! Let's try it : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string folderPath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFileThatDoesNotExists\" ; bool exists = currentWeb . DoesFolderExists ( folderPath ); if ( exists ) { // Do something } else { // Do something else } } And that's it ! The DoesFolderExists Method provides this test. And it also works with folder hierarchy containing special characters \ud83d\ude09. For testing the existance of a file, there's not any equivalent. So if you try to get a file that doesn't exists : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string filePath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFileThatDoesNotExists\" ; File fileToGet = currentWeb . GetFileByServerRelativeUrl ( filePath ); spContext . Load ( fileToGet , f => f . Exists ); try { spContext . ExecuteQuery (); } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } } It'll also throw an exception. So the thing here is to use the GetFileByServerRelativePath method which returns a File object, whether it exists or not. And there : the \"Exists\" property can be used. The great thing about this method is that it also works if you file (or your folder hierarchy) contains special characters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string filePath = docLibrary . RootFolder . ServerRelativeUrl + \"/# My Tricky File \u00fch\u00fch\u00fc.docx\" ; File fileToGet = currentWeb . GetFileByServerRelativePath ( ResourcePath . FromDecodedUrl ( filePath )); spContext . Load ( fileToGet , f => f . Exists ); try { spContext . ExecuteQuery (); if ( fileToGet . Exists ) { // Do something } else { // Do something else } } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } }","title":"A Simple Use Case"},{"location":"tips/20200213-csom-test-file-folder-existence/#bonus-using-the-windows-credential-manager","text":"For Windows users, if you don't want to always write your credentials and if you already know the Add / Get -PnPStoredCredential cmdlets, you might be interested to use the CredentialManager class provided by the Adys Tech company. You can fin the Nugget package here . Then, when referencing it, you just have to use it like this: 1 2 3 var cred = CredentialManager . GetCredentials ( \"PnPPS:CredentialsName\" ); string user = cred . UserName ; SecureString pwd = cred . SecurePassword ;","title":"Bonus : Using the Windows Credential Manager"},{"location":"tips/20200213-csom-test-file-folder-existence/#useful-links","text":"FileFolderExtensions.DoesFolderExists from SharePoint Online PnP Core Supporting % and # in files and folders with the ResourcePath API","title":"Useful Links"},{"location":"tips/20200505-spfx-progressindicator-to-countdown-timer/","text":"[SPFx] Transform the Fluent UI ProgressIndicator component into a countdown timer Info As you know, the well-know Office UI Fabric front-end infrastructure has been renamed as Fluent UI ! (more info here ) Recently, I had to develop a certification exam with SPFx. One of the features was to provide a countdown within the questions. As I'm familiar with React and the Fluent UI components, I was wondering if it was possible to reuse the ProgressIndicator component and set it up in reverse mode. So here we go ! Existing sample First, let's have a look at the sample provided here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import * as React from 'react' ; import { ProgressIndicator } from 'office-ui-fabric-react/lib/ProgressIndicator' ; import { Async } from 'office-ui-fabric-react/lib/Utilities' ; export interface IProgressIndicatorBasicExampleState { percentComplete : number ; } const INTERVAL_DELAY = 100 ; const INTERVAL_INCREMENT = 0.01 ; const RESTART_WAIT_TIME = 2000 ; export class ProgressIndicatorBasicExample extends React . Component < {}, IProgressIndicatorBasicExampleState > { private _interval : number ; private _async : Async ; constructor ( props : {}) { super ( props ); this . _async = new Async ( this ); this . state = { percentComplete : 0 , }; this . _startProgressDemo = this . _startProgressDemo . bind ( this ); } public componentDidMount () : void { this . _startProgressDemo (); } public componentWillUnmount () : void { this . _async . dispose (); } public render () : JSX . Element { const { percentComplete } = this . state ; return ( < ProgressIndicator label = \"Example title\" description = \"Example description\" percentComplete = { percentComplete } /> ); } private _startProgressDemo () : void { // reset the demo this . setState ({ percentComplete : 0 , }); // update progress this . _interval = this . _async . setInterval (() => { let percentComplete = this . state . percentComplete + INTERVAL_INCREMENT ; // once complete, set the demo to start again if ( percentComplete >= 1.0 ) { percentComplete = 1.0 ; this . _async . clearInterval ( this . _interval ); this . _async . setTimeout ( this . _startProgressDemo , RESTART_WAIT_TIME ); } this . setState ({ percentComplete : percentComplete , }); }, INTERVAL_DELAY ); } } This code gives this behavior: Countdown mode Now, let's reverse the process. Let's say that you want your countdown set to 30 seconds. You can replace the const variable INTERVAL_INCREMENT (which won't be used anymore) by COUNTDOWN_DURATION . For this demo, the duration will be in milliseconds. 1 2 3 4 5 6 7 8 9 10 11 12 import * as React from 'react' ; import { ProgressIndicator } from 'office-ui-fabric-react/lib/ProgressIndicator' ; import { Async } from 'office-ui-fabric-react/lib/Utilities' ; export interface IProgressIndicatorBasicExampleState { percentComplete : number ; } const INTERVAL_DELAY = 100 ; const COUNTDOWN_DURATION = 30000 ; const RESTART_WAIT_TIME = 2000 ; //... Then, you can set the percentComplete state to 1 in the constructor (remember that this variable is used as a parameter of the component, which goes from 0 to 1). So that the initial state of the Indicator is 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //... export class ProgressIndicatorBasicExample extends React . Component < {}, IProgressIndicatorBasicExampleState > { private _interval : number ; private _async : Async ; constructor ( props : {}) { super ( props ); this . _async = new Async ( this ); this . state = { percentComplete : 1 , // --> initial state }; this . _startProgressDemo = this . _startProgressDemo . bind ( this ); } //... } In the method called when the component is mounted, make the same update. 1 2 3 4 5 6 7 8 //... private _startProgressDemo () : void { // reset the demo this . setState ({ percentComplete : 1 , }); //... } Now comes the tricky part. When you want to properly decrease the progress indicator, you have to calculate the value to decrease from 1 (the initial state, remember ?). This depends on the delay of the countdown. You can add this variable as a private member of the component. 1 2 3 4 5 6 7 8 //... export class ProgressIndicatorBasicExample extends React . Component < {}, IProgressIndicatorBasicExampleState > { private _interval : number ; private _async : Async ; // value = [initial state of ProgressIndicator] / [countdown duration in milliseconds] / [interval of refresh in milliseconds] private _intervalDecrement : number = 1 / COUNTDOWN_DURATION / INTERVAL_DELAY ; //... } We want now to calculate the remaining time of the countdown, to refresh the progress indicator component. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //... this . _interval = this . _async . setInterval (() => { let percentComplete = this . state . percentComplete - this . _intervalDecrement ; // once 0 reached, set the demo to start again if ( percentComplete <= 0 ) { this . _async . clearInterval ( this . _interval ); this . _async . setTimeout ( this . _startProgressDemo , RESTART_WAIT_TIME ); } this . setState ({ percentComplete : percentComplete , }); }, INTERVAL_DELAY ) Updated code So here is the complete updated code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import * as React from 'react' ; import { ProgressIndicator } from 'office-ui-fabric-react/lib/ProgressIndicator' ; import { Async } from 'office-ui-fabric-react/lib/Utilities' ; export interface IProgressIndicatorBasicExampleState { percentComplete : number ; } const INTERVAL_DELAY = 100 ; const COUNTDOWN_DURATION = 30000 ; const RESTART_WAIT_TIME = 2000 ; export class ProgressIndicatorBasicExample extends React . Component < {}, IProgressIndicatorBasicExampleState > { private _interval : number ; private _async : Async ; // value = [initial state of ProgressIndicator] / ([countdown duration in milliseconds] / [interval of refresh in milliseconds]) private _intervalDecrement : number = 1 / ( COUNTDOWN_DURATION / INTERVAL_DELAY ); constructor ( props : {}) { super ( props ); this . _async = new Async ( this ); this . state = { percentComplete : 1 , // --> initial state }; this . _startProgressDemo = this . _startProgressDemo . bind ( this ); } public componentDidMount () : void { this . _startProgressDemo (); } public componentWillUnmount () : void { this . _async . dispose (); } public render () : JSX . Element { const { percentComplete } = this . state ; return ( < ProgressIndicator label = \"Example title\" description = \"Example description\" percentComplete = { percentComplete } /> ); } private _startProgressDemo () : void { // reset the demo this . setState ({ percentComplete : 1 , }); this . _interval = this . _async . setInterval (() => { let percentComplete = this . state . percentComplete - this . _intervalDecrement ; // once 0 reached, set the demo to start again if ( percentComplete <= 0 ) { this . _async . clearInterval ( this . _interval ); this . _async . setTimeout ( this . _startProgressDemo , RESTART_WAIT_TIME ); } this . setState ({ percentComplete : percentComplete , }); }, INTERVAL_DELAY ) } } And that's it! You can find the Codepen example here . Furthermore If you want this control to be reset (for example from a question to another in a session exam), you can turn it into a fully uncontrolled component using a key ! You can also add some text to display the remaining time like this: 1 2 3 4 5 6 7 8 9 10 11 12 //... constructor ( props ) { super ( props ); this . _async = new Async ( this ); this . state = { percentComplete : 1 , timeLeft : COUNTDOWN_DURATION , // --> init timeleft to 30 seconds }; } //... 1 2 3 4 5 6 7 8 9 public render () : JSX . Element { const { percentComplete } = this . state ; return ( < ProgressIndicator label = { `Remaining time : ${ this . state . timeLeft > 0 ? Math . floor ( this . state . timeLeft / 1000 ) : 0 } seconds` } percentComplete = { percentComplete } /> ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //... private _startProgressDemo () : void { // reset the demo this . setState ({ percentComplete : 1 , timeLeft : COUNTDOWN_DURATION , }); this . _interval = this . _async . setInterval (() => { let percentComplete = this . state . percentComplete - this . _intervalDecrement ; let remainingTime = this . state . timeLeft - INTERVAL_DELAY ; // --> update the remaining time // once 0 reached, set the demo to start again if ( percentComplete <= 0 ) { this . _async . clearInterval ( this . _interval ); this . _async . setTimeout ( this . _startProgressDemo , RESTART_WAIT_TIME ); } this . setState ({ percentComplete : percentComplete , timeLeft : remainingTime , }); }, INTERVAL_DELAY ) } Here's the result: You could change the color of the progress indicator component regarding the remaining time and so on... Use your imagination \ud83d\ude09 Happy coding! (Thanks to Charlie B for its help)","title":"[SPFx] Transform the Fluent UI ProgressIndicator  component into a countdown timer"},{"location":"tips/20200505-spfx-progressindicator-to-countdown-timer/#spfx-transform-the-fluent-ui-progressindicator-component-into-a-countdown-timer","text":"Info As you know, the well-know Office UI Fabric front-end infrastructure has been renamed as Fluent UI ! (more info here ) Recently, I had to develop a certification exam with SPFx. One of the features was to provide a countdown within the questions. As I'm familiar with React and the Fluent UI components, I was wondering if it was possible to reuse the ProgressIndicator component and set it up in reverse mode. So here we go !","title":"[SPFx] Transform the Fluent UI ProgressIndicator  component into a countdown timer"},{"location":"tips/20200505-spfx-progressindicator-to-countdown-timer/#existing-sample","text":"First, let's have a look at the sample provided here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import * as React from 'react' ; import { ProgressIndicator } from 'office-ui-fabric-react/lib/ProgressIndicator' ; import { Async } from 'office-ui-fabric-react/lib/Utilities' ; export interface IProgressIndicatorBasicExampleState { percentComplete : number ; } const INTERVAL_DELAY = 100 ; const INTERVAL_INCREMENT = 0.01 ; const RESTART_WAIT_TIME = 2000 ; export class ProgressIndicatorBasicExample extends React . Component < {}, IProgressIndicatorBasicExampleState > { private _interval : number ; private _async : Async ; constructor ( props : {}) { super ( props ); this . _async = new Async ( this ); this . state = { percentComplete : 0 , }; this . _startProgressDemo = this . _startProgressDemo . bind ( this ); } public componentDidMount () : void { this . _startProgressDemo (); } public componentWillUnmount () : void { this . _async . dispose (); } public render () : JSX . Element { const { percentComplete } = this . state ; return ( < ProgressIndicator label = \"Example title\" description = \"Example description\" percentComplete = { percentComplete } /> ); } private _startProgressDemo () : void { // reset the demo this . setState ({ percentComplete : 0 , }); // update progress this . _interval = this . _async . setInterval (() => { let percentComplete = this . state . percentComplete + INTERVAL_INCREMENT ; // once complete, set the demo to start again if ( percentComplete >= 1.0 ) { percentComplete = 1.0 ; this . _async . clearInterval ( this . _interval ); this . _async . setTimeout ( this . _startProgressDemo , RESTART_WAIT_TIME ); } this . setState ({ percentComplete : percentComplete , }); }, INTERVAL_DELAY ); } } This code gives this behavior:","title":"Existing sample"},{"location":"tips/20200505-spfx-progressindicator-to-countdown-timer/#countdown-mode","text":"Now, let's reverse the process. Let's say that you want your countdown set to 30 seconds. You can replace the const variable INTERVAL_INCREMENT (which won't be used anymore) by COUNTDOWN_DURATION . For this demo, the duration will be in milliseconds. 1 2 3 4 5 6 7 8 9 10 11 12 import * as React from 'react' ; import { ProgressIndicator } from 'office-ui-fabric-react/lib/ProgressIndicator' ; import { Async } from 'office-ui-fabric-react/lib/Utilities' ; export interface IProgressIndicatorBasicExampleState { percentComplete : number ; } const INTERVAL_DELAY = 100 ; const COUNTDOWN_DURATION = 30000 ; const RESTART_WAIT_TIME = 2000 ; //... Then, you can set the percentComplete state to 1 in the constructor (remember that this variable is used as a parameter of the component, which goes from 0 to 1). So that the initial state of the Indicator is 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //... export class ProgressIndicatorBasicExample extends React . Component < {}, IProgressIndicatorBasicExampleState > { private _interval : number ; private _async : Async ; constructor ( props : {}) { super ( props ); this . _async = new Async ( this ); this . state = { percentComplete : 1 , // --> initial state }; this . _startProgressDemo = this . _startProgressDemo . bind ( this ); } //... } In the method called when the component is mounted, make the same update. 1 2 3 4 5 6 7 8 //... private _startProgressDemo () : void { // reset the demo this . setState ({ percentComplete : 1 , }); //... } Now comes the tricky part. When you want to properly decrease the progress indicator, you have to calculate the value to decrease from 1 (the initial state, remember ?). This depends on the delay of the countdown. You can add this variable as a private member of the component. 1 2 3 4 5 6 7 8 //... export class ProgressIndicatorBasicExample extends React . Component < {}, IProgressIndicatorBasicExampleState > { private _interval : number ; private _async : Async ; // value = [initial state of ProgressIndicator] / [countdown duration in milliseconds] / [interval of refresh in milliseconds] private _intervalDecrement : number = 1 / COUNTDOWN_DURATION / INTERVAL_DELAY ; //... } We want now to calculate the remaining time of the countdown, to refresh the progress indicator component. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //... this . _interval = this . _async . setInterval (() => { let percentComplete = this . state . percentComplete - this . _intervalDecrement ; // once 0 reached, set the demo to start again if ( percentComplete <= 0 ) { this . _async . clearInterval ( this . _interval ); this . _async . setTimeout ( this . _startProgressDemo , RESTART_WAIT_TIME ); } this . setState ({ percentComplete : percentComplete , }); }, INTERVAL_DELAY )","title":"Countdown mode"},{"location":"tips/20200505-spfx-progressindicator-to-countdown-timer/#updated-code","text":"So here is the complete updated code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import * as React from 'react' ; import { ProgressIndicator } from 'office-ui-fabric-react/lib/ProgressIndicator' ; import { Async } from 'office-ui-fabric-react/lib/Utilities' ; export interface IProgressIndicatorBasicExampleState { percentComplete : number ; } const INTERVAL_DELAY = 100 ; const COUNTDOWN_DURATION = 30000 ; const RESTART_WAIT_TIME = 2000 ; export class ProgressIndicatorBasicExample extends React . Component < {}, IProgressIndicatorBasicExampleState > { private _interval : number ; private _async : Async ; // value = [initial state of ProgressIndicator] / ([countdown duration in milliseconds] / [interval of refresh in milliseconds]) private _intervalDecrement : number = 1 / ( COUNTDOWN_DURATION / INTERVAL_DELAY ); constructor ( props : {}) { super ( props ); this . _async = new Async ( this ); this . state = { percentComplete : 1 , // --> initial state }; this . _startProgressDemo = this . _startProgressDemo . bind ( this ); } public componentDidMount () : void { this . _startProgressDemo (); } public componentWillUnmount () : void { this . _async . dispose (); } public render () : JSX . Element { const { percentComplete } = this . state ; return ( < ProgressIndicator label = \"Example title\" description = \"Example description\" percentComplete = { percentComplete } /> ); } private _startProgressDemo () : void { // reset the demo this . setState ({ percentComplete : 1 , }); this . _interval = this . _async . setInterval (() => { let percentComplete = this . state . percentComplete - this . _intervalDecrement ; // once 0 reached, set the demo to start again if ( percentComplete <= 0 ) { this . _async . clearInterval ( this . _interval ); this . _async . setTimeout ( this . _startProgressDemo , RESTART_WAIT_TIME ); } this . setState ({ percentComplete : percentComplete , }); }, INTERVAL_DELAY ) } } And that's it! You can find the Codepen example here .","title":"Updated code"},{"location":"tips/20200505-spfx-progressindicator-to-countdown-timer/#furthermore","text":"If you want this control to be reset (for example from a question to another in a session exam), you can turn it into a fully uncontrolled component using a key ! You can also add some text to display the remaining time like this: 1 2 3 4 5 6 7 8 9 10 11 12 //... constructor ( props ) { super ( props ); this . _async = new Async ( this ); this . state = { percentComplete : 1 , timeLeft : COUNTDOWN_DURATION , // --> init timeleft to 30 seconds }; } //... 1 2 3 4 5 6 7 8 9 public render () : JSX . Element { const { percentComplete } = this . state ; return ( < ProgressIndicator label = { `Remaining time : ${ this . state . timeLeft > 0 ? Math . floor ( this . state . timeLeft / 1000 ) : 0 } seconds` } percentComplete = { percentComplete } /> ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //... private _startProgressDemo () : void { // reset the demo this . setState ({ percentComplete : 1 , timeLeft : COUNTDOWN_DURATION , }); this . _interval = this . _async . setInterval (() => { let percentComplete = this . state . percentComplete - this . _intervalDecrement ; let remainingTime = this . state . timeLeft - INTERVAL_DELAY ; // --> update the remaining time // once 0 reached, set the demo to start again if ( percentComplete <= 0 ) { this . _async . clearInterval ( this . _interval ); this . _async . setTimeout ( this . _startProgressDemo , RESTART_WAIT_TIME ); } this . setState ({ percentComplete : percentComplete , timeLeft : remainingTime , }); }, INTERVAL_DELAY ) } Here's the result: You could change the color of the progress indicator component regarding the remaining time and so on... Use your imagination \ud83d\ude09 Happy coding! (Thanks to Charlie B for its help)","title":"Furthermore"}]}