{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Articles 2020-02-11 : How to quickly and properly delete a Team (without waiting) Tips & Tricks 2020-02-13 : [CSOM] Test in your C# code if a SharePoint File or Folder exists","title":"Home"},{"location":"#articles","text":"2020-02-11 : How to quickly and properly delete a Team (without waiting)","title":"Articles"},{"location":"#tips-tricks","text":"2020-02-13 : [CSOM] Test in your C# code if a SharePoint File or Folder exists","title":"Tips &amp; Tricks"},{"location":"about/","text":"About this blog Who Am I Hi ! I'm Micha\u00ebl, Software Engineer for onepoint based in Nantes, France. I'm +10yr experienced in SharePoint solutions (started from the 2007 version) and since 2017, I'm focused on developing SPFx solutions, working with Office 365 Managed Services and Azure Services, exploring Microsoft Graph and Identity. I also (try to) contribute to the PnP Initiative with amazing people ! In this blog, I'll talk about things I learned day by day since I started to work with SharePoint Products (articles, memos,...). Why Now It's hard to convince yourself \"Ok, let's open to the world\". I think I was waiting for the right time. When I see how the Microsoft Community has grown up, especially in the Office 365 bubble, I think that it could be helpful to anyone who, like me, wants to find some answers to technical issues met (missing puzzle piece \ud83d\ude09). Why In English Because it's easier to reach out a maximum of people \ud83e\udd17 Hope you'll find what you're looking for, see you online or IRL !","title":"About"},{"location":"about/#about-this-blog","text":"","title":"About this blog"},{"location":"about/#who-am-i","text":"Hi ! I'm Micha\u00ebl, Software Engineer for onepoint based in Nantes, France. I'm +10yr experienced in SharePoint solutions (started from the 2007 version) and since 2017, I'm focused on developing SPFx solutions, working with Office 365 Managed Services and Azure Services, exploring Microsoft Graph and Identity. I also (try to) contribute to the PnP Initiative with amazing people ! In this blog, I'll talk about things I learned day by day since I started to work with SharePoint Products (articles, memos,...).","title":"Who Am I"},{"location":"about/#why-now","text":"It's hard to convince yourself \"Ok, let's open to the world\". I think I was waiting for the right time. When I see how the Microsoft Community has grown up, especially in the Office 365 bubble, I think that it could be helpful to anyone who, like me, wants to find some answers to technical issues met (missing puzzle piece \ud83d\ude09).","title":"Why Now"},{"location":"about/#why-in-english","text":"Because it's easier to reach out a maximum of people \ud83e\udd17 Hope you'll find what you're looking for, see you online or IRL !","title":"Why In English"},{"location":"articles/20200211-properly-remove-team/","text":"How to quickly and properly delete a Team (without waiting) Use Case You work for a company that wants to automatically create a Team with Tabs, Channels and other stuff that will make a new project team ready to rock the stage. You are preparing the process and for mastering it, you have create / test / destroy / retry. But when you want to clean up your mess, you have to know that, during 30 days: Your Team still exists as a Group (you can find it in the \"Deleted Groups\" menu on AAD), same for the associated e-mail address The Teams Site also still exists So let's says that you made a mistake during the creation of a Team and want to \"start over\" (with same name of course), if you don't want to wait for the Office 365 Job to update your environment and re-create the Team with same name: The SharePoint Site URL takes a number at the end of its address (of course, because the older one's still here) You can't permanently delete the Teams Site, as the SharePoint Admin Center detects that the related Group still exists Here's a step by step process to delete quickly a Team ! I recommand to follow them in this order to make everything's work. Prerequisites An Office 365 (Dev) Tenant An Account with the following Office 365 roles SharePoint Admin Teams Admin An Account with the following Azure AD role Groups administrator PowerShell or Office 365 CLI Delete Group in Azure With Interface Throught the UI, you have to delete the Group then permanently delete it With code PowerShell 1 2 3 4 # With the AAD PowerShell **2.0-preview** module Connect-AzureAD -TenantId \"TenantId\" Remove-AzureADGroup -ObjectId \"GroupId\" Remove-AzureADMSDeletedDirectoryObject -Id \"GroupId\" Office 365 CLI 1 2 3 # (As there's no CLI command to permanently delete a Group, # you'll have to do it through the UI) aad o365group remove --id \"groupId\" --confirm Delete Team (if necessary) Sometimes, once a Group is permanently deleted, the Team still exists. If it's the case and once again, you don't want for the Job to delete it, you can do it yourself. But don't be surprise if the following commands throw an error : maybe the Job has already worked. With Interface Throught the UI (if you have an owner account) or Admin Interface, you can delete the Team OR With the Teams PowerShell module 1 2 Connect-MicrosoftTeams -TenantId \"TenantId\" Remove-Team -GroupId \"GroupId\" Delete Site Collection As I told you before (even if you did the previous steps), if you try to delete the Teams Site from the SharePoint Admin Center, you won't be able to remove it from the Site Collection Recycle Bin (because of the O365 Job Tenant update process). With code So the solution here is to delete the Site with PowerShell (SharePoint PnP PoweShell module), like this: PowerShell 1 2 3 4 5 6 7 # If you are familiar with the Get-PnPStoredCredential cmdlet, # you can use it here with the \"-Credential\" Argument Connect-PnPOnline -TenantId \"TenantId\" Remove-PnPTenantSite -Url \"TeamsSiteUrl\" -Force -SkipRecycleBin # If it's already in Recycle Bin Clear-PnPTenantRecycleBinItem -Url \"TeamsSiteUrl\" -Force -Wait Office 365 CLI 1 2 3 4 # (If it's already in Site Collection Recycle Bin, you'll have to delete it # from the UI or through another API like SharePoint or Graph) spo site classic remove -u \"url\" --skipRecycleBin --confirm --wait That's it Et voil\u00e0 ! You can start over your process until it's ready to use. Of course, you could also make those tasks with the SharePoint Online Management Shell or with the Graph API, but here I've covered the most common ways of working with Teams / Group / SharePoint administration. Useful Links AAD PowerShell module SharePointPnPPowerShellOnline module MicrosoftTeams PowerShell module Office 365 CLI Microsoft Teams Architecture Microsoft Teams Architecture Posters","title":"How to quickly and properly delete a Team (without waiting)"},{"location":"articles/20200211-properly-remove-team/#how-to-quickly-and-properly-delete-a-team-without-waiting","text":"","title":"How to quickly and properly delete a Team (without waiting)"},{"location":"articles/20200211-properly-remove-team/#use-case","text":"You work for a company that wants to automatically create a Team with Tabs, Channels and other stuff that will make a new project team ready to rock the stage. You are preparing the process and for mastering it, you have create / test / destroy / retry. But when you want to clean up your mess, you have to know that, during 30 days: Your Team still exists as a Group (you can find it in the \"Deleted Groups\" menu on AAD), same for the associated e-mail address The Teams Site also still exists So let's says that you made a mistake during the creation of a Team and want to \"start over\" (with same name of course), if you don't want to wait for the Office 365 Job to update your environment and re-create the Team with same name: The SharePoint Site URL takes a number at the end of its address (of course, because the older one's still here) You can't permanently delete the Teams Site, as the SharePoint Admin Center detects that the related Group still exists Here's a step by step process to delete quickly a Team ! I recommand to follow them in this order to make everything's work.","title":"Use Case"},{"location":"articles/20200211-properly-remove-team/#prerequisites","text":"An Office 365 (Dev) Tenant An Account with the following Office 365 roles SharePoint Admin Teams Admin An Account with the following Azure AD role Groups administrator PowerShell or Office 365 CLI","title":"Prerequisites"},{"location":"articles/20200211-properly-remove-team/#delete-group-in-azure","text":"","title":"Delete Group in Azure"},{"location":"articles/20200211-properly-remove-team/#with-interface","text":"Throught the UI, you have to delete the Group then permanently delete it","title":"With Interface"},{"location":"articles/20200211-properly-remove-team/#with-code","text":"PowerShell 1 2 3 4 # With the AAD PowerShell **2.0-preview** module Connect-AzureAD -TenantId \"TenantId\" Remove-AzureADGroup -ObjectId \"GroupId\" Remove-AzureADMSDeletedDirectoryObject -Id \"GroupId\" Office 365 CLI 1 2 3 # (As there's no CLI command to permanently delete a Group, # you'll have to do it through the UI) aad o365group remove --id \"groupId\" --confirm","title":"With code"},{"location":"articles/20200211-properly-remove-team/#delete-team-if-necessary","text":"Sometimes, once a Group is permanently deleted, the Team still exists. If it's the case and once again, you don't want for the Job to delete it, you can do it yourself. But don't be surprise if the following commands throw an error : maybe the Job has already worked.","title":"Delete Team (if necessary)"},{"location":"articles/20200211-properly-remove-team/#with-interface_1","text":"Throught the UI (if you have an owner account) or Admin Interface, you can delete the Team OR","title":"With Interface"},{"location":"articles/20200211-properly-remove-team/#with-the-teams-powershell-module","text":"1 2 Connect-MicrosoftTeams -TenantId \"TenantId\" Remove-Team -GroupId \"GroupId\"","title":"With the Teams PowerShell module"},{"location":"articles/20200211-properly-remove-team/#delete-site-collection","text":"As I told you before (even if you did the previous steps), if you try to delete the Teams Site from the SharePoint Admin Center, you won't be able to remove it from the Site Collection Recycle Bin (because of the O365 Job Tenant update process).","title":"Delete Site Collection"},{"location":"articles/20200211-properly-remove-team/#with-code_1","text":"So the solution here is to delete the Site with PowerShell (SharePoint PnP PoweShell module), like this: PowerShell 1 2 3 4 5 6 7 # If you are familiar with the Get-PnPStoredCredential cmdlet, # you can use it here with the \"-Credential\" Argument Connect-PnPOnline -TenantId \"TenantId\" Remove-PnPTenantSite -Url \"TeamsSiteUrl\" -Force -SkipRecycleBin # If it's already in Recycle Bin Clear-PnPTenantRecycleBinItem -Url \"TeamsSiteUrl\" -Force -Wait Office 365 CLI 1 2 3 4 # (If it's already in Site Collection Recycle Bin, you'll have to delete it # from the UI or through another API like SharePoint or Graph) spo site classic remove -u \"url\" --skipRecycleBin --confirm --wait","title":"With code"},{"location":"articles/20200211-properly-remove-team/#thats-it","text":"Et voil\u00e0 ! You can start over your process until it's ready to use. Of course, you could also make those tasks with the SharePoint Online Management Shell or with the Graph API, but here I've covered the most common ways of working with Teams / Group / SharePoint administration.","title":"That's it"},{"location":"articles/20200211-properly-remove-team/#useful-links","text":"AAD PowerShell module SharePointPnPPowerShellOnline module MicrosoftTeams PowerShell module Office 365 CLI Microsoft Teams Architecture Microsoft Teams Architecture Posters","title":"Useful Links"},{"location":"tips/20200213-csom-test-file-folder-existence/","text":"[CSOM] Test in your C# code if a SharePoint File or Folder exists A Simple Use Case When you want to know if a file or folder already exists on a SharePoint Site (in a migration use case for example, before perform a copy / move), you can have some bad surprises. Let's try with a simple folder case example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 string userName = \"user@tenant.onmicrosoft.com\" ; SecureString securePassword = new SecureString (); foreach ( var cc in \"yourPlainTextPassword\" ) { securePassword . AppendChar ( cc ); } using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { spContext . Credentials = new SharePointOnlineCredentials ( userName , securePassword ); spContext . ExecuteQuery (); Web currentWeb = spContext . Web ; List docLibrary = currentWeb . Lists . GetByTitle ( \"Documents\" ); spContext . Load ( docLibrary ); spContext . Load ( docLibrary . RootFolder ); spContext . ExecuteQuery (); string folderPath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFolderThatDoesNotExists\" ; Folder folderToGet = currentWeb . GetFolderByServerRelativeUrl ( folderPath ); spContext . Load ( folderToGet , f => f . Exists ); try { spContext . ExecuteQuery (); if ( folderToGet . Exists ) { // Do something } else { // Do something else } } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } } The twisted thing here's that the if (folderToGet.Exists) line won't be reached. Because if you use the \"GetFolderByServerRelativeUrl\" and the folder actually doesn't exists (or any parent folder in the hierarchy), it'll throw an exception. But if it exists, then you'll be able to test the value of folderToGet.Exists property (which obviously will return true ). Clever. So you want to test if a folder exists but without to constantly catch the error... Good news : the SharePointPnPCoreOnline Package implements this ! Let's try it : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string folderPath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFileThatDoesNotExists\" ; bool exists = currentWeb . DoesFolderExists ( folderPath ); if ( exists ) { // Do something } else { // Do something else } } And that's it ! The DoesFolderExists Method provides this test. And it also works with folder hierarchy containing special characters \ud83d\ude09. For testing the existance of a file, there's not any equivalent. So if you try to get a file that doesn't exists : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string filePath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFileThatDoesNotExists\" ; File fileToGet = currentWeb . GetFileByServerRelativeUrl ( filePath ); spContext . Load ( fileToGet , f => f . Exists ); try { spContext . ExecuteQuery (); } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } } It'll also throw an exception. So the thing here is to use the GetFileByServerRelativePath method which returns a File object, whether it exists or not. And there : the \"Exists\" property can be used. The great thing about this method is that it also works if you file (or your folder hierarchy) contains special characters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string filePath = docLibrary . RootFolder . ServerRelativeUrl + \"/# My Tricky File \u00fch\u00fch\u00fc.docx\" ; File fileToGet = currentWeb . GetFileByServerRelativePath ( ResourcePath . FromDecodedUrl ( filePath )); spContext . Load ( fileToGet , f => f . Exists ); try { spContext . ExecuteQuery (); if ( fileToGet . Exists ) { // Do something } else { // Do something else } } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } } Bonus : Using the Windows Credential Manager For Windows users, if you don't want to always write your credentials and if you already know the Add / Get -PnPStoredCredential cmdlets, you might be interested to use the CredentialManager class provided by the Adys Tech company. You can fin the Nugget package here . Then, when referencing it, you just have to use it like this: 1 2 3 var cred = CredentialManager . GetCredentials ( \"PnPPS:CredentialsName\" ); string user = cred . UserName ; SecureString pwd = cred . SecurePassword ; Useful Links FileFolderExtensions.DoesFolderExists from SharePoint Online PnP Core Supporting % and # in files and folders with the ResourcePath API","title":"[CSOM] Test in your C# code if a SharePoint File or Folder exists"},{"location":"tips/20200213-csom-test-file-folder-existence/#csom-test-in-your-c-code-if-a-sharepoint-file-or-folder-exists","text":"","title":"[CSOM] Test in your C# code if a SharePoint File or Folder exists"},{"location":"tips/20200213-csom-test-file-folder-existence/#a-simple-use-case","text":"When you want to know if a file or folder already exists on a SharePoint Site (in a migration use case for example, before perform a copy / move), you can have some bad surprises. Let's try with a simple folder case example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 string userName = \"user@tenant.onmicrosoft.com\" ; SecureString securePassword = new SecureString (); foreach ( var cc in \"yourPlainTextPassword\" ) { securePassword . AppendChar ( cc ); } using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { spContext . Credentials = new SharePointOnlineCredentials ( userName , securePassword ); spContext . ExecuteQuery (); Web currentWeb = spContext . Web ; List docLibrary = currentWeb . Lists . GetByTitle ( \"Documents\" ); spContext . Load ( docLibrary ); spContext . Load ( docLibrary . RootFolder ); spContext . ExecuteQuery (); string folderPath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFolderThatDoesNotExists\" ; Folder folderToGet = currentWeb . GetFolderByServerRelativeUrl ( folderPath ); spContext . Load ( folderToGet , f => f . Exists ); try { spContext . ExecuteQuery (); if ( folderToGet . Exists ) { // Do something } else { // Do something else } } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } } The twisted thing here's that the if (folderToGet.Exists) line won't be reached. Because if you use the \"GetFolderByServerRelativeUrl\" and the folder actually doesn't exists (or any parent folder in the hierarchy), it'll throw an exception. But if it exists, then you'll be able to test the value of folderToGet.Exists property (which obviously will return true ). Clever. So you want to test if a folder exists but without to constantly catch the error... Good news : the SharePointPnPCoreOnline Package implements this ! Let's try it : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string folderPath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFileThatDoesNotExists\" ; bool exists = currentWeb . DoesFolderExists ( folderPath ); if ( exists ) { // Do something } else { // Do something else } } And that's it ! The DoesFolderExists Method provides this test. And it also works with folder hierarchy containing special characters \ud83d\ude09. For testing the existance of a file, there's not any equivalent. So if you try to get a file that doesn't exists : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string filePath = docLibrary . RootFolder . ServerRelativeUrl + \"/MyFileThatDoesNotExists\" ; File fileToGet = currentWeb . GetFileByServerRelativeUrl ( filePath ); spContext . Load ( fileToGet , f => f . Exists ); try { spContext . ExecuteQuery (); } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } } It'll also throw an exception. So the thing here is to use the GetFileByServerRelativePath method which returns a File object, whether it exists or not. And there : the \"Exists\" property can be used. The great thing about this method is that it also works if you file (or your folder hierarchy) contains special characters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Credentials declaration like above ... using ( ClientContext spContext = new ClientContext ( \"SharePointSiteUrl\" )) { // Connection like above ... string filePath = docLibrary . RootFolder . ServerRelativeUrl + \"/# My Tricky File \u00fch\u00fch\u00fc.docx\" ; File fileToGet = currentWeb . GetFileByServerRelativePath ( ResourcePath . FromDecodedUrl ( filePath )); spContext . Load ( fileToGet , f => f . Exists ); try { spContext . ExecuteQuery (); if ( fileToGet . Exists ) { // Do something } else { // Do something else } } catch ( Exception ex ) { Console . WriteLine ( ex . Message ); } }","title":"A Simple Use Case"},{"location":"tips/20200213-csom-test-file-folder-existence/#bonus-using-the-windows-credential-manager","text":"For Windows users, if you don't want to always write your credentials and if you already know the Add / Get -PnPStoredCredential cmdlets, you might be interested to use the CredentialManager class provided by the Adys Tech company. You can fin the Nugget package here . Then, when referencing it, you just have to use it like this: 1 2 3 var cred = CredentialManager . GetCredentials ( \"PnPPS:CredentialsName\" ); string user = cred . UserName ; SecureString pwd = cred . SecurePassword ;","title":"Bonus : Using the Windows Credential Manager"},{"location":"tips/20200213-csom-test-file-folder-existence/#useful-links","text":"FileFolderExtensions.DoesFolderExists from SharePoint Online PnP Core Supporting % and # in files and folders with the ResourcePath API","title":"Useful Links"}]}